<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design System - Part 2: Dragonfly Architecture Deep Dive</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 10px;
        }
        h3 {
            color: #546e7a;
            margin-top: 20px;
        }
        p {
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        pre {
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 20px 0;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .intro {
            background-color: #e3f2fd;
            padding: 15px;
            border-left: 4px solid #2196f3;
            margin: 20px 0;
        }
        .key-point {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        .section-divider {
            border-top: 1px solid #ddd;
            margin: 40px 0;
        }
        .emoji {
            font-style: normal;
        }
    </style>
</head>
<body>
    <h1>Design System - Part 2: Dragonfly Architecture Deep Dive</h1>

    <div class="intro">
        <p>In <a href="1.dragonfly.html">Part 1</a>, we compared DragonflyDB and Redis, showing how Dragonfly achieves up to 25x higher throughput. Now, let's dive deep into the source code to understand <strong>how</strong> Dragonfly's architecture makes this possible.</p>
    </div>

    <h2>Architecture Overview</h2>

    <p><strong>Dragonfly</strong> is a modern Redis/Memcached-compatible in-memory datastore built in C++ that achieves exceptional performance through innovative architectural decisions optimized for modern multi-core hardware.</p>

    <h3>Core Design Principles</h3>

    <table>
        <thead>
            <tr>
                <th>Principle</th>
                <th>Description</th>
                <th>Benefit</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Shared-Nothing Architecture</td>
                <td>Partitions data across threads with no shared state</td>
                <td>Eliminates lock contention</td>
            </tr>
            <tr>
                <td>Lock-Free Transactions</td>
                <td>Uses VLL (Very Lightweight Locking) algorithm</td>
                <td>High concurrency without spin-locks</td>
            </tr>
            <tr>
                <td>Efficient Data Structures</td>
                <td>Based on DASH (Dynamic And Scalable Hashing)</td>
                <td>Cache-friendly, lock-free reads</td>
            </tr>
            <tr>
                <td>Multi-Protocol Support</td>
                <td>Redis and Memcached APIs simultaneously</td>
                <td>Drop-in replacement flexibility</td>
            </tr>
        </tbody>
    </table>

    <div class="section-divider"></div>

    <h2>Source Code Structure</h2>

    <p>The <code>/src</code> directory is organized into 4 main components, each with specific responsibilities:</p>

    <pre><code>src/
├── server/      # Main server logic, command handlers, replication
├── core/        # Core data structures (DASH table, allocators, etc.)
├── facade/      # Network protocol handlers (Redis RESP, Memcached)
└── redis/       # Redis C library integration</code></pre>

    <h3>1. Server Layer (<code>/src/server/</code>)</h3>

    <p>Contains 119 .cc files and 92 .h files implementing the main server logic.</p>

    <table>
        <thead>
            <tr>
                <th>Component</th>
                <th>File</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Entry Point</td>
                <td><code>dfly_main.cc</code></td>
                <td>Application entry point, initializes everything</td>
            </tr>
            <tr>
                <td>Service Orchestrator</td>
                <td><code>main_service.cc</code></td>
                <td>Registers ~185 Redis commands</td>
            </tr>
            <tr>
                <td>Shard Management</td>
                <td><code>engine_shard_set.{h,cc}</code></td>
                <td>Manages the sharded architecture</td>
            </tr>
            <tr>
                <td>Individual Shard</td>
                <td><code>engine_shard.{h,cc}</code></td>
                <td>Per-thread shard management</td>
            </tr>
            <tr>
                <td>Database Instance</td>
                <td><code>db_slice.{h,cc}</code></td>
                <td>Per-shard database instance</td>
            </tr>
            <tr>
                <td>Transactions</td>
                <td><code>transaction.{h,cc}</code></td>
                <td>Transaction framework using VLL algorithm</td>
            </tr>
        </tbody>
    </table>

    <h4>Command Families</h4>

    <p>Each command family implements a group of Redis commands:</p>

    <ul>
        <li><strong>string_family</strong> - SET, GET, INCR, etc.</li>
        <li><strong>hset_family</strong> - HSET, HGET (hashes)</li>
        <li><strong>list_family</strong> - LPUSH, RPOP (lists)</li>
        <li><strong>set_family</strong> - SADD, SINTER (sets)</li>
        <li><strong>zset_family</strong> - ZADD, ZRANGE (sorted sets)</li>
        <li><strong>json_family</strong> - JSON operations</li>
        <li><strong>stream_family</strong> - Redis Streams</li>
        <li><strong>bloom_family</strong> - Bloom filters</li>
        <li><strong>search_family</strong> - Full-text search</li>
    </ul>

    <h4>Advanced Features</h4>

    <ul>
        <li><code>acl/</code> - Access Control Lists</li>
        <li><code>cluster/</code> - Cluster mode support</li>
        <li><code>journal/</code> - Replication journaling</li>
        <li><code>tiering/</code> - Tiered storage (RAM + SSD)</li>
        <li><code>rdb_save.cc</code>, <code>rdb_load.cc</code> - Redis RDB format persistence</li>
        <li><code>snapshot.cc</code> - Fork-less snapshotting</li>
    </ul>

    <h3>2. Core Layer (<code>/src/core/</code>)</h3>

    <p>Contains 70 .cc files and 60 .h files with critical data structures:</p>

    <table>
        <thead>
            <tr>
                <th>Data Structure</th>
                <th>File</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DASH Hashtable</td>
                <td><code>dash.h</code></td>
                <td>Scalable concurrent hash table with lock-free reads and incremental resizing</td>
            </tr>
            <tr>
                <td>Dense Set</td>
                <td><code>dense_set.{h,cc}</code></td>
                <td>Compact set implementation</td>
            </tr>
            <tr>
                <td>Compact Object</td>
                <td><code>compact_object.{h,cc}</code></td>
                <td>Memory-efficient object representation</td>
            </tr>
            <tr>
                <td>Memory Resource</td>
                <td><code>mi_memory_resource.{h,cc}</code></td>
                <td>Custom memory allocator using mimalloc</td>
            </tr>
            <tr>
                <td>Intent Lock</td>
                <td><code>intent_lock.h</code></td>
                <td>Lock management for VLL transactions</td>
            </tr>
            <tr>
                <td>Transaction Queue</td>
                <td><code>tx_queue.{h,cc}</code></td>
                <td>Transaction queue management</td>
            </tr>
        </tbody>
    </table>

    <h4>Specialized Components</h4>

    <ul>
        <li><code>json/</code> - JSON path operations</li>
        <li><code>search/</code> - Search indexing (AST, lexer, parser)</li>
        <li><code>bloom.cc</code> - Bloom filter implementation</li>
        <li><code>count_min_sketch.cc</code> - Probabilistic counting</li>
        <li><code>qlist.cc</code> - Quicklist (Redis list implementation)</li>
    </ul>

    <h3>3. Facade Layer (<code>/src/facade/</code>)</h3>

    <p>Contains 21 .cc files and 18 .h files handling network protocols:</p>

    <table>
        <thead>
            <tr>
                <th>Component</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>dragonfly_listener.{h,cc}</code></td>
                <td>TCP listener for incoming connections</td>
            </tr>
            <tr>
                <td><code>dragonfly_connection.{h,cc}</code></td>
                <td>Connection state machine</td>
            </tr>
            <tr>
                <td><code>redis_parser.{h,cc}</code></td>
                <td>Redis RESP protocol parser</td>
            </tr>
            <tr>
                <td><code>memcache_parser.{h,cc}</code></td>
                <td>Memcached protocol parser</td>
            </tr>
            <tr>
                <td><code>reply_builder.{h,cc}</code></td>
                <td>Response formatting</td>
            </tr>
            <tr>
                <td><code>service_interface.h</code></td>
                <td>Abstract interface for command execution</td>
            </tr>
        </tbody>
    </table>

    <h3>4. Redis Integration (<code>/src/redis/</code>)</h3>

    <p>Contains vendored Redis C library code for compatibility with Redis data structures and algorithms. Key components include:</p>

    <ul>
        <li><code>sds.{c,h}</code> - Simple Dynamic Strings</li>
        <li><code>listpack.{c,h}</code> - Compact list encoding</li>
        <li><code>quicklist.{c,h}</code> - Redis list implementation</li>
        <li><code>rax.{c,h}</code> - Radix tree (used for streams)</li>
        <li><code>intset.{c,h}</code> - Integer set implementation</li>
        <li><code>hyperloglog.c</code> - HyperLogLog probabilistic counting</li>
        <li><code>geo.c</code>, <code>geohash.c</code> - Geospatial indexing</li>
    </ul>

    <div class="key-point">
        <strong>Key Modification:</strong> Dragonfly created <code>zmalloc_mi.c</code> to use <strong>mimalloc</strong> instead of Redis's default allocator, providing better performance and lower fragmentation.
    </div>

    <div class="section-divider"></div>

    <h2>How Dragonfly Runs</h2>

    <h3>Startup Sequence</h3>

    <pre><code>main()                                    // dfly_main.cc
  ↓
Initialize ProactorPool                   // Thread pool for I/O
  ↓
Create EngineShardSet                     // Shared-nothing shards
  ↓
Initialize MainService                    // Command registry
  ↓
Register Command Families                 // 185+ Redis commands
  ↓
Start Listeners                          // Redis (6379), Memcached, HTTP
  ↓
Event Loop                               // Process commands</code></pre>

    <h3>Request Processing Flow</h3>

    <pre><code>Client Connection
  ↓
[Facade Layer]
  ↓ Parse Protocol (RESP/Memcached)
  ↓
[MainService]
  ↓ Lookup Command in Registry
  ↓
[Transaction Framework]
  ↓ Determine Affected Shards
  ↓ Acquire Intent Locks (VLL)
  ↓
[Shard Execution] (Parallel)
  ↓ Execute on Each Shard
  ↓ Access DbSlice (per-shard DB)
  ↓ Modify DASH Table
  ↓
[Facade Layer]
  ↓ Format Response
  ↓
Return to Client</code></pre>

    <h3>Shared-Nothing Architecture</h3>

    <p>Each thread manages its own shard independently:</p>

    <pre><code>// Each thread manages its own shard
EngineShardSet creates N shards = N threads
Each EngineShard has:
  - DbSlice (database instance)
  - FiberQueue (work queue)
  - DASH table (hash table)</code></pre>

    <h3>Transaction Coordination</h3>

    <p>Multi-key operations coordinate across shards efficiently:</p>

    <pre><code>// Multi-key operations coordinate across shards
Transaction tx;
tx.InitByKeys(keys);              // Determine shards
tx.ScheduleSingleHop([]{          // Execute on shards
  // Runs on each shard in parallel
  auto* shard = EngineShard::tlocal();
  shard->db_slice()->Find(key);
});</code></pre>

    <h3>Lock-Free Coordination (VLL)</h3>

    <ul>
        <li>Uses <strong>Intent Locks</strong> instead of traditional locks</li>
        <li>Transactions ordered by transaction ID</li>
        <li>No spin-locks or mutexes for common operations</li>
        <li>Enables high concurrency without contention</li>
    </ul>

    <div class="section-divider"></div>

    <h2>Performance Innovations</h2>

    <h3>1. DASH Table</h3>

    <ul>
        <li>Cache-line aligned buckets for CPU efficiency</li>
        <li>Incremental resizing without blocking operations</li>
        <li>Lock-free reads for maximum throughput</li>
        <li>Stash buckets for collision handling</li>
    </ul>

    <h3>2. Memory Efficiency</h3>

    <table>
        <thead>
            <tr>
                <th>Technique</th>
                <th>Description</th>
                <th>Benefit</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>CompactObject</td>
                <td>Stores small strings inline (&lt; 24 bytes)</td>
                <td>Reduces memory allocations</td>
            </tr>
            <tr>
                <td>SmallString</td>
                <td>Optimized string storage</td>
                <td>Lower memory overhead</td>
            </tr>
            <tr>
                <td>mimalloc</td>
                <td>Fast memory allocator</td>
                <td>Low fragmentation, high performance</td>
            </tr>
            <tr>
                <td>Tiered Storage</td>
                <td>Offload cold data to SSD</td>
                <td>Scale beyond RAM capacity</td>
            </tr>
        </tbody>
    </table>

    <h3>3. Novel Eviction Algorithm</h3>

    <ul>
        <li><strong>Zero memory overhead</strong> - No LRU lists required</li>
        <li>Uses access patterns in the DASH table itself</li>
        <li>Predicts future access probability</li>
        <li>Configurable with <code>--cache_mode=true</code></li>
    </ul>

    <h3>4. Fork-less Snapshotting</h3>

    <ul>
        <li>Uses copy-on-write at the data structure level</li>
        <li>No OS fork() overhead</li>
        <li>Minimal memory increase during snapshot</li>
        <li>Faster than Redis BGSAVE</li>
    </ul>

    <div class="section-divider"></div>

    <h2>Execution Model</h2>

    <h3>Thread Model</h3>

    <pre><code>Main Thread
  ├── I/O Proactor Thread 1 → EngineShard 1 → DbSlice 1
  ├── I/O Proactor Thread 2 → EngineShard 2 → DbSlice 2
  ├── ...
  └── I/O Proactor Thread N → EngineShard N → DbSlice N</code></pre>

    <h3>Fiber-based Concurrency</h3>

    <ul>
        <li>Each thread runs <strong>fibers</strong> (lightweight coroutines)</li>
        <li>Multiple client connections per thread</li>
        <li>Non-blocking I/O with io_uring (Linux) or epoll</li>
        <li>No callback hell - sequential code with async benefits</li>
    </ul>

    <h3>Data Sharding Strategy</h3>

    <pre><code>// Keys distributed via hash
ShardId shard = Shard(key, num_shards);

// Single-key operations → one shard
SET key value  // Runs on shard(hash(key))

// Multi-key operations → multiple shards
MSET k1 v1 k2 v2  // Coordinates across shards

// Global operations → all shards
FLUSHDB  // Runs on all shards</code></pre>

    <div class="section-divider"></div>

    <h2>Command Processing Example: SET Command</h2>

    <p>Let's trace how a simple <code>SET key value</code> command flows through the system:</p>

    <pre><code>1. Client sends: "*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n"
   
2. RedisParser::Parse() → ["SET", "key", "value"]

3. MainService::DispatchCommand()
   - Lookup "SET" → StringFamily::Set()
   
4. Transaction::InitByArgs(["key"])
   - Calculate shard: hash("key") % num_shards = 3
   
5. Transaction::ScheduleSingleHop()
   - Dispatch to Shard 3's FiberQueue
   
6. EngineShard::tlocal() on Shard 3
   - DbSlice::AddOrUpdate("key", "value")
   - DASH table insert
   
7. ReplyBuilder::SendSimpleString("OK")

8. Client receives: "+OK\r\n"</code></pre>

    <div class="section-divider"></div>

    <h2>Redis Integration: Vendored Code Strategy</h2>

    <p>Dragonfly takes a hybrid approach with Redis code:</p>

    <table>
        <thead>
            <tr>
                <th>What Dragonfly Uses</th>
                <th>What Dragonfly Doesn't Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>✅ Redis data structures (sds, listpack, quicklist)</td>
                <td>❌ Redis networking layer</td>
            </tr>
            <tr>
                <td>✅ Redis algorithms (hyperloglog, geo)</td>
                <td>❌ Redis dict</td>
            </tr>
            <tr>
                <td>✅ Redis RDB format</td>
                <td>❌ Redis event loop</td>
            </tr>
            <tr>
                <td>✅ Redis Lua integration</td>
                <td>❌ Redis transaction system</td>
            </tr>
            <tr>
                <td>✅ Modified zmalloc (using mimalloc)</td>
                <td>❌ Redis cluster implementation</td>
            </tr>
        </tbody>
    </table>

    <div class="key-point">
        <strong>Why This Approach?</strong>
        <ul>
            <li><strong>API Compatibility</strong> - Using actual Redis code ensures exact behavior</li>
            <li><strong>Battle-Tested</strong> - Redis data structures are highly optimized</li>
            <li><strong>Time Savings</strong> - No need to reimplement complex structures</li>
            <li><strong>Format Compatibility</strong> - RDB files, wire protocol match exactly</li>
        </ul>
    </div>

    <h3>Custom Memory Allocator Integration</h3>

    <p>Dragonfly's most significant modification to Redis code:</p>

    <pre><code>// src/redis/zmalloc_mi.c
// Copyright 2022, DragonflyDB authors. All rights reserved.

#include &lt;mimalloc.h&gt;

void* zmalloc(size_t size) {
  assert(zmalloc_heap);
  void* res = mi_heap_malloc(zmalloc_heap, size);  // Uses mimalloc!
  size_t usable = mi_usable_size(res);
  zmalloc_used_memory_tl += usable;
  return res;
}</code></pre>

    <div class="section-divider"></div>

    <h2>Build System</h2>

    <pre><code># CMakeLists.txt structure
src/CMakeLists.txt
  ├── add_subdirectory(redis)     # Redis C library
  ├── add_subdirectory(core)      # Core data structures
  ├── add_subdirectory(facade)    # Protocol handlers
  └── add_subdirectory(server)    # Main server binary

# Main executable: dragonfly
# Test executables: *_test</code></pre>

    <h3>Build Dependencies</h3>

    <ul>
        <li>C++20 compiler (GCC/Clang)</li>
        <li>mimalloc (custom memory allocator)</li>
        <li>Abseil (Google's C++ library)</li>
        <li>io_uring (Linux async I/O)</li>
        <li>xxHash (fast hashing)</li>
    </ul>

    <div class="section-divider"></div>

    <h2>Key Takeaways</h2>

    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Implementation</th>
                <th>Impact</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Shared-Nothing</td>
                <td>Each thread is independent, no contention</td>
                <td>Linear scalability with CPU cores</td>
            </tr>
            <tr>
                <td>VLL Transactions</td>
                <td>Coordination without locks</td>
                <td>High concurrency without blocking</td>
            </tr>
            <tr>
                <td>DASH Table</td>
                <td>Fast, scalable hash table</td>
                <td>Lock-free reads, efficient resizing</td>
            </tr>
            <tr>
                <td>Fibers</td>
                <td>Lightweight concurrency within threads</td>
                <td>Handle many connections efficiently</td>
            </tr>
            <tr>
                <td>Multi-Protocol</td>
                <td>Same port serves Redis, Memcached, HTTP</td>
                <td>Flexibility and compatibility</td>
            </tr>
            <tr>
                <td>Memory Efficiency</td>
                <td>Compact representations, efficient allocator</td>
                <td>Better memory utilization</td>
            </tr>
            <tr>
                <td>Tiered Storage</td>
                <td>Scale beyond RAM with SSD offloading</td>
                <td>Cost-effective large datasets</td>
            </tr>
        </tbody>
    </table>

    <div class="intro">
        <p><strong>This architecture is why Dragonfly achieves 25X throughput compared to single-threaded Redis while maintaining full API compatibility!</strong></p>
        <p>By combining innovative shared-nothing design, lock-free data structures, and efficient memory management with battle-tested Redis data structures, Dragonfly delivers the best of both worlds: cutting-edge performance and proven reliability.</p>
    </div>

    <h2>What's Next?</h2>

    <p>In Part 3, we'll explore practical implementation patterns, deployment strategies, and real-world use cases for integrating Dragonfly into your system architecture.</p>

    <p><a href="1.dragonfly.html">← Back to Part 1: DragonflyDB vs Redis Comparison</a></p>

</body>
</html>
